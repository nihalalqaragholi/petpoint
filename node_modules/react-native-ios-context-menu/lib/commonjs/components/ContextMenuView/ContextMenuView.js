"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NATIVE_ID_KEYS = exports.ContextMenuView = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");
var _tsEventEmitter = require("@dominicstop/ts-event-emitter");
var _reactNativeIosUtilities = require("react-native-ios-utilities");
var _RNIContextMenuView = require("../../native_components/RNIContextMenuView");
var _ContextMenuViewContext = require("../../context/ContextMenuViewContext");
var _LibEnv = require("../../constants/LibEnv");
var Helpers = _interopRequireWildcard(require("../../functions/Helpers"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
const NATIVE_ID_KEYS = exports.NATIVE_ID_KEYS = {
  detachedView: 'detachedView',
  contextMenuPreview: 'contextMenuPreview',
  contextMenuAuxiliaryPreview: 'contextMenuAuxiliaryPreview'
};
class ContextMenuView extends _react.default.PureComponent {
  static defaultProps = {
    useActionSheetFallback: !_LibEnv.LIB_ENV.isContextMenuViewSupported
  };
  constructor(props) {
    super(props);
    this.state = {
      menuVisible: false,
      mountPreview: false
    };
    this.emitter = new _tsEventEmitter.TSEventEmitter();
  }
  getProps = () => {
    const {
      menuConfig,
      previewConfig,
      auxiliaryPreviewConfig,
      shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle,
      shouldWaitForMenuToHideBeforeFiringOnPressMenuItem,
      shouldEnableAggressiveCleanup,
      shouldCleanupOnComponentWillUnmountForMenuPreview,
      shouldCleanupOnComponentWillUnmountForAuxPreview,
      isAuxiliaryPreviewEnabled,
      isContextMenuEnabled,
      shouldPreventLongPressGestureFromPropagating,
      // internal
      debugShouldEnableLogging,
      // event props
      onMenuWillShow,
      onMenuWillHide,
      onMenuWillCancel,
      onMenuDidShow,
      onMenuDidHide,
      onMenuDidCancel,
      onRequestDeferredElement,
      onMenuAuxiliaryPreviewWillShow,
      onMenuAuxiliaryPreviewDidShow,
      onPressMenuItem,
      onPressMenuPreview,
      lazyPreview,
      // render props
      renderPreview,
      renderAuxiliaryPreview: renderAuxillaryPreview,
      ...viewProps
    } = this.props;
    return {
      // A. Provide default values to props...
      lazyPreview: lazyPreview ?? true,
      shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle: shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle ?? true,
      shouldWaitForMenuToHideBeforeFiringOnPressMenuItem: shouldWaitForMenuToHideBeforeFiringOnPressMenuItem ?? true,
      shouldEnableAggressiveCleanup: shouldEnableAggressiveCleanup ?? true,
      isAuxiliaryPreviewEnabled: isAuxiliaryPreviewEnabled ?? true,
      isContextMenuEnabled: isContextMenuEnabled ?? true,
      shouldPreventLongPressGestureFromPropagating: shouldPreventLongPressGestureFromPropagating ?? true,
      debugShouldEnableLogging: debugShouldEnableLogging ?? _LibEnv.LIB_ENV.shouldEnableLogging,
      // B. Pass down props...
      shouldCleanupOnComponentWillUnmountForMenuPreview,
      shouldCleanupOnComponentWillUnmountForAuxPreview,
      menuConfig,
      previewConfig,
      auxiliaryPreviewConfig,
      // C. Pass down, and group event props...
      eventProps: {
        onMenuWillShow,
        onMenuWillHide,
        onMenuWillCancel,
        onMenuDidShow,
        onMenuDidHide,
        onMenuDidCancel,
        onRequestDeferredElement,
        onMenuAuxiliaryPreviewWillShow,
        onMenuAuxiliaryPreviewDidShow,
        onPressMenuItem,
        onPressMenuPreview
      },
      // D. Pass down, and group render props
      renderProps: {
        renderPreview,
        renderAuxillaryPreview
      },
      // E. Move all the default view-related
      //    props here...
      viewProps
    };
  };
  dismissMenu = async () => {
    if (!_LibEnv.LIB_ENV.isContextMenuViewSupported) return;
    await this.nativeRef.dismissMenu();
  };
  provideDeferredElements = async (deferredID, menuItems) => {
    if (!_LibEnv.LIB_ENV.isContextMenuViewSupported) return;
    await this.nativeRef.provideDeferredElements(deferredID, menuItems);
  };
  presentMenu = async () => {
    if (!_LibEnv.LIB_ENV.isContextMenuViewSupported) return;
    await this.nativeRef.presentMenu();
  };
  showAuxiliaryPreviewAsPopover = async () => {
    if (!_LibEnv.LIB_ENV.isContextMenuViewSupported) return;
    await Helpers.setStateAsync(this, () => ({
      mountPreview: true
    }));
    await this.nativeRef.showAuxiliaryPreviewAsPopover();
  };
  _handleGetRefToContextMenuView = () => {
    return this;
  };
  _handleOnMenuWillCreate = event => {
    this.setState({
      mountPreview: true
    });
    event.stopPropagation();
  };
  _handleOnMenuWillShow = event => {
    var _this$props$onMenuWil, _this$props;
    (_this$props$onMenuWil = (_this$props = this.props).onMenuWillShow) === null || _this$props$onMenuWil === void 0 || _this$props$onMenuWil.call(_this$props, event);
    event.stopPropagation();
    this.setState({
      menuVisible: true,
      mountPreview: true
    });
  };
  _handleOnMenuWillHide = event => {
    var _this$props$onMenuWil2, _this$props2;
    (_this$props$onMenuWil2 = (_this$props2 = this.props).onMenuWillHide) === null || _this$props$onMenuWil2 === void 0 || _this$props$onMenuWil2.call(_this$props2, event);
    event.stopPropagation();
    this.setState({
      menuVisible: false
    });
  };
  _handleOnMenuWillCancel = event => {
    var _this$props$onMenuWil3, _this$props3;
    (_this$props$onMenuWil3 = (_this$props3 = this.props).onMenuWillCancel) === null || _this$props$onMenuWil3 === void 0 || _this$props$onMenuWil3.call(_this$props3, event);
    event.stopPropagation();
  };
  _handleOnMenuDidShow = event => {
    var _this$props$onMenuDid, _this$props4;
    (_this$props$onMenuDid = (_this$props4 = this.props).onMenuDidShow) === null || _this$props$onMenuDid === void 0 || _this$props$onMenuDid.call(_this$props4, event);
    event.stopPropagation();
  };
  _handleOnMenuDidHide = event => {
    var _this$props$onMenuDid2, _this$props5;
    (_this$props$onMenuDid2 = (_this$props5 = this.props).onMenuDidHide) === null || _this$props$onMenuDid2 === void 0 || _this$props$onMenuDid2.call(_this$props5, event);
    this.emitter.emit('onMenuDidHide', event);
    event.stopPropagation();
    event.persist();
    this.setState({
      mountPreview: false
    });
  };
  _handleOnMenuDidCancel = event => {
    var _this$props$onMenuDid3, _this$props6;
    (_this$props$onMenuDid3 = (_this$props6 = this.props).onMenuDidCancel) === null || _this$props$onMenuDid3 === void 0 || _this$props$onMenuDid3.call(_this$props6, event);

    // guard: event is a native event
    if (event.isUsingActionSheetFallback) return;
    event.stopPropagation();
  };
  _handleOnRequestDeferredElement = event => {
    const {
      onRequestDeferredElement
    } = this.props;
    const {
      deferredID
    } = event.nativeEvent;
    onRequestDeferredElement === null || onRequestDeferredElement === void 0 || onRequestDeferredElement(deferredID, items => {
      this.provideDeferredElements(deferredID, items);
    });
  };
  _handleOnMenuAuxiliaryPreviewWillShow = event => {
    var _this$props$onMenuAux, _this$props7;
    (_this$props$onMenuAux = (_this$props7 = this.props).onMenuAuxiliaryPreviewWillShow) === null || _this$props$onMenuAux === void 0 || _this$props$onMenuAux.call(_this$props7, event);
    event.stopPropagation();
  };
  _handleOnMenuAuxiliaryPreviewDidShow = event => {
    var _this$props$onMenuAux2, _this$props8;
    (_this$props$onMenuAux2 = (_this$props8 = this.props).onMenuAuxiliaryPreviewDidShow) === null || _this$props$onMenuAux2 === void 0 || _this$props$onMenuAux2.call(_this$props8, event);
    event.stopPropagation();
  };
  _handleOnPressMenuItem = async event => {
    var _event$nativeEvent$me;
    const props = this.getProps();
    const eventProps = props.eventProps;
    event.stopPropagation();
    event.persist();
    const isKeepsMenuPresentedEnabled = (_event$nativeEvent$me = event.nativeEvent.menuAttributes) === null || _event$nativeEvent$me === void 0 ? void 0 : _event$nativeEvent$me.includes('keepsMenuPresented');
    const shouldWaitForMenuToHide = !isKeepsMenuPresentedEnabled && props.shouldWaitForMenuToHideBeforeFiringOnPressMenuItem;
    try {
      if (shouldWaitForMenuToHide) {
        var _eventProps$onPressMe;
        // wait for `onMenuDidHide`
        await Helpers.promiseWithTimeout(1000, new Promise(resolve => {
          this.emitter.once('onMenuDidHide', () => {
            resolve();
          });
        }));
        (_eventProps$onPressMe = eventProps.onPressMenuItem) === null || _eventProps$onPressMe === void 0 || _eventProps$onPressMe.call(eventProps, event);
      } else {
        var _eventProps$onPressMe2;
        (_eventProps$onPressMe2 = eventProps.onPressMenuItem) === null || _eventProps$onPressMe2 === void 0 || _eventProps$onPressMe2.call(eventProps, event);
      }
      ;
    } catch (error) {
      var _eventProps$onPressMe3;
      (_eventProps$onPressMe3 = eventProps.onPressMenuItem) === null || _eventProps$onPressMe3 === void 0 || _eventProps$onPressMe3.call(eventProps, event);
      console.log('_handleOnPressMenuItem - Promise waiting for `onMenuDidHide`' + ' has timed out');
    }
    ;
  };
  _handleOnPressMenuPreview = event => {
    var _this$props$onPressMe, _this$props9;
    (_this$props$onPressMe = (_this$props9 = this.props).onPressMenuPreview) === null || _this$props$onPressMe === void 0 || _this$props$onPressMe.call(_this$props9, event);
    event.stopPropagation();
  };
  render() {
    var _props$renderProps$re, _props$renderProps, _props$renderProps$re2, _props$renderProps2;
    const props = this.getProps();
    const state = this.state;
    const shouldUseContextMenuView = _LibEnv.LIB_ENV.isContextMenuViewSupported;
    const isUsingCustomPreview = props.renderProps.renderPreview != null;
    const shouldMountPreviewContent = state.mountPreview || !props.lazyPreview;
    const isUsingAuxillaryPreview = props.renderProps.renderAuxillaryPreview != null;
    const shouldMountAuxPreviewContent = state.mountPreview || !props.lazyPreview;
    const shouldMountDetachedView = isUsingCustomPreview || isUsingAuxillaryPreview;
    props.debugShouldEnableLogging && console.log("ContextMenuView.render", `\n - isUsingCustomPreview: ${isUsingCustomPreview}`, `\n - shouldMountPreviewContent: ${shouldMountPreviewContent}`, `\n - isUsingAuxillaryPreview: ${isUsingAuxillaryPreview}`, `\n - shouldMountAuxPreviewContent: ${shouldMountAuxPreviewContent}`, `\n - shouldMountDetachedView: ${shouldMountDetachedView}`, `\n`);
    const contents = shouldUseContextMenuView ?
    /*#__PURE__*/
    // A - Use Context Menu View
    _react.default.createElement(_RNIContextMenuView.RNIContextMenuView, _extends({}, props.viewProps, {
      ref: ref => {
        this.nativeRef = ref;
      },
      style: [styles.menuView, props.viewProps.style],
      menuConfig: props.menuConfig,
      previewConfig: props.previewConfig,
      auxiliaryPreviewConfig: props.auxiliaryPreviewConfig,
      isContextMenuEnabled: props.isContextMenuEnabled,
      shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle: props.shouldUseDiscoverabilityTitleAsFallbackValueForSubtitle,
      isAuxiliaryPreviewEnabled: props.isAuxiliaryPreviewEnabled,
      shouldPreventLongPressGestureFromPropagating: props.shouldPreventLongPressGestureFromPropagating,
      debugShouldEnableLogging: props.debugShouldEnableLogging

      // Events: `onPress`-Related
      ,
      onMenuWillShow: this._handleOnMenuWillShow,
      onMenuWillHide: this._handleOnMenuWillHide,
      onMenuWillCancel: this._handleOnMenuWillCancel,
      onMenuDidShow: this._handleOnMenuDidShow,
      onMenuDidHide: this._handleOnMenuDidHide,
      onMenuDidCancel: this._handleOnMenuDidCancel,
      onRequestDeferredElement: this._handleOnRequestDeferredElement,
      onMenuWillCreate: this._handleOnMenuWillCreate

      // Events: "Aux. Preview"-Related
      ,
      onMenuAuxiliaryPreviewWillShow: this._handleOnMenuAuxiliaryPreviewWillShow,
      onMenuAuxiliaryPreviewDidShow: this._handleOnMenuAuxiliaryPreviewDidShow

      // Events: `onPress`-Related
      ,
      onPressMenuItem: this._handleOnPressMenuItem,
      onPressMenuPreview: this._handleOnPressMenuPreview
    }), shouldMountDetachedView && /*#__PURE__*/_react.default.createElement(_reactNativeIosUtilities.RNIDetachedView, {
      nativeID: NATIVE_ID_KEYS.detachedView,
      shouldImmediatelyDetach: true
    }, /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, isUsingCustomPreview && /*#__PURE__*/_react.default.createElement(_reactNativeIosUtilities.RNIDetachedViewContent, {
      nativeID: NATIVE_ID_KEYS.contextMenuPreview
    }, shouldMountPreviewContent && ((_props$renderProps$re = (_props$renderProps = props.renderProps).renderPreview) === null || _props$renderProps$re === void 0 ? void 0 : _props$renderProps$re.call(_props$renderProps)))), /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, isUsingAuxillaryPreview && /*#__PURE__*/_react.default.createElement(_reactNativeIosUtilities.RNIDetachedViewContent, {
      nativeID: NATIVE_ID_KEYS.contextMenuAuxiliaryPreview
    }, shouldMountAuxPreviewContent && ((_props$renderProps$re2 = (_props$renderProps2 = props.renderProps).renderAuxillaryPreview) === null || _props$renderProps$re2 === void 0 ? void 0 : _props$renderProps$re2.call(_props$renderProps2))))), /*#__PURE__*/_react.default.createElement(_reactNative.View, null, props.viewProps.children)) :
    /*#__PURE__*/
    // B - Use Regular View
    _react.default.createElement(_reactNative.View, props.viewProps, this.props.children);
    return /*#__PURE__*/_react.default.createElement(_ContextMenuViewContext.ContextMenuViewContext.Provider, {
      value: {
        getRefToContextMenuView: this._handleGetRefToContextMenuView,
        isMenuVisible: state.menuVisible
      }
    }, contents);
  }
}
exports.ContextMenuView = ContextMenuView;
;
const styles = _reactNative.StyleSheet.create({
  menuView: {
    backgroundColor: 'transparent'
  }
});
//# sourceMappingURL=ContextMenuView.js.map